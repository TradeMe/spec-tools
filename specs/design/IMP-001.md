# IMP-001: Rate Limiter Middleware Implementation

**Version**: 1.0
**Created**: 2025-10-31
**Status**: Active

## Overview

This document provides detailed implementation specifications for the Rate Limiting Middleware component described in [SOL-001](../architecture/solutions/SOL-001.md). The middleware will be implemented as an NGINX Lua module that integrates with Redis to enforce distributed rate limits across the API gateway cluster.

**Implementation Language**: Lua 5.1 (LuaJIT 2.1)
**Target Platform**: NGINX 1.25+ with lua-nginx-module
**External Dependencies**: redis-lua library, cjson library

## Implements

- [SOL-001](../architecture/solutions/SOL-001.md): Rate Limiting Solution Architecture

## Addresses

- [REQ-006](../requirements/REQ-006.md): Distributed Rate Limiting System

## API Specifications

### API-01: Rate Limiter Initialization

```lua
-- Initialize rate limiter with configuration
-- Called during NGINX init phase
function RateLimiter:new(config)
    -- config: {
    --   redis_host: string,
    --   redis_port: number,
    --   redis_timeout: number (ms),
    --   redis_pool_size: number,
    --   default_algorithm: string,
    --   fail_mode: "open" | "closed"
    -- }
    -- Returns: RateLimiter instance or nil, error
end
```

**Purpose**: Create a new rate limiter instance with Redis connection pool and configuration.

**Parameters**:
- `config.redis_host`: Redis server hostname or IP
- `config.redis_port`: Redis server port (default: 6379)
- `config.redis_timeout`: Connection timeout in milliseconds (default: 100)
- `config.redis_pool_size`: Connection pool size per worker (default: 10)
- `config.default_algorithm`: Default algorithm if not specified in policy
- `config.fail_mode`: Behavior when Redis unavailable ("open" allows, "closed" denies)

**Returns**: Initialized RateLimiter object or `nil` with error message

**Example**:
```lua
local limiter, err = RateLimiter:new({
    redis_host = "redis.internal",
    redis_port = 6379,
    redis_timeout = 100,
    redis_pool_size = 20,
    default_algorithm = "token_bucket",
    fail_mode = "open"
})
if not limiter then
    ngx.log(ngx.ERR, "Failed to initialize rate limiter: ", err)
    return ngx.exit(500)
end
```

### API-02: Check Rate Limit

```lua
-- Check if request should be allowed or rate limited
function RateLimiter:check_limit(client_id, policy)
    -- client_id: string identifying the client
    -- policy: {
    --   algorithm: "token_bucket" | "sliding_window" | "fixed_window",
    --   limit: number,
    --   period: number (seconds),
    --   burst: number (optional, for token_bucket)
    -- }
    -- Returns: {
    --   allowed: boolean,
    --   limit: number,
    --   remaining: number,
    --   reset: number (unix timestamp)
    -- }
end
```

**Purpose**: Evaluate a request against a rate limit policy and return decision.

**Parameters**:
- `client_id`: Unique identifier for the client (API key, IP address, user ID)
- `policy.algorithm`: Rate limiting algorithm to use
- `policy.limit`: Maximum requests allowed per period
- `policy.period`: Time period in seconds
- `policy.burst`: Additional burst capacity (token bucket only)

**Returns**: Table with rate limit decision:
- `allowed`: true if request allowed, false if rate limited
- `limit`: Configured limit value
- `remaining`: Number of requests remaining in current period
- `reset`: Unix timestamp when quota resets

**Example**:
```lua
local result = limiter:check_limit("api_key_12345", {
    algorithm = "token_bucket",
    limit = 1000,
    period = 3600,
    burst = 50
})

if not result.allowed then
    ngx.status = 429
    ngx.header["X-RateLimit-Limit"] = result.limit
    ngx.header["X-RateLimit-Remaining"] = result.remaining
    ngx.header["X-RateLimit-Reset"] = result.reset
    ngx.header["Retry-After"] = result.reset - ngx.time()
    ngx.say(cjson.encode({
        error = "Rate limit exceeded",
        limit = result.limit,
        reset = result.reset
    }))
    return ngx.exit(429)
end
```

### API-03: Get Client Identifier

```lua
-- Extract client identifier from request
function RateLimiter:get_client_id(strategy)
    -- strategy: "api_key" | "ip" | "user_id" | "composite"
    -- Returns: string client identifier or nil, error
end
```

**Purpose**: Extract client identifier from HTTP request based on configured strategy.

**Parameters**:
- `strategy`: Identification strategy to use
  - `"api_key"`: Extract from `X-API-Key` header
  - `"ip"`: Use client IP address (with X-Forwarded-For support)
  - `"user_id"`: Extract from authenticated user context
  - `"composite"`: Combine multiple identifiers

**Returns**: Client identifier string or `nil` with error

**Example**:
```lua
local client_id, err = limiter:get_client_id("api_key")
if not client_id then
    ngx.log(ngx.WARN, "Could not identify client: ", err)
    client_id = limiter:get_client_id("ip")  -- fallback to IP
end
```

### API-04: Add Rate Limit Headers

```lua
-- Add rate limit headers to response
function RateLimiter:add_headers(result)
    -- result: Rate limit check result from check_limit()
    -- Returns: void (modifies ngx.header)
end
```

**Purpose**: Add standard rate limit headers to HTTP response.

**Parameters**:
- `result`: Result object from `check_limit()` call

**Headers Added**:
- `X-RateLimit-Limit`: Maximum requests allowed
- `X-RateLimit-Remaining`: Requests remaining in current window
- `X-RateLimit-Reset`: Unix timestamp when limit resets
- `Retry-After`: Seconds until quota resets (when rate limited)

**Example**:
```lua
local result = limiter:check_limit(client_id, policy)
limiter:add_headers(result)
```

### API-05: Reset Client Quota

```lua
-- Reset quota for a specific client (admin operation)
function RateLimiter:reset_quota(client_id, policy_id)
    -- client_id: Client whose quota to reset
    -- policy_id: Policy identifier (for multi-policy scenarios)
    -- Returns: boolean success, string error
end
```

**Purpose**: Administrative function to reset a client's quota (e.g., after manual review).

**Parameters**:
- `client_id`: Client identifier to reset
- `policy_id`: Optional policy identifier for targeted reset

**Returns**: `true` on success, `false` with error message on failure

**Example**:
```lua
local ok, err = limiter:reset_quota("api_key_12345", "hourly_limit")
if not ok then
    ngx.log(ngx.ERR, "Failed to reset quota: ", err)
end
```

## Data Models

### DM-01: Policy Configuration

The policy configuration defines how rate limits are enforced for different clients and endpoints.

```lua
-- Policy configuration structure
Policy = {
    -- Unique policy identifier
    id = "string",

    -- Human-readable policy name
    name = "string",

    -- Rate limiting algorithm
    algorithm = "token_bucket" | "sliding_window" | "fixed_window",

    -- Quota limit (requests per period)
    limit = number,

    -- Time period in seconds
    period = number,

    -- Burst capacity (token_bucket only)
    burst = number | nil,

    -- Client tier this policy applies to
    tier = "free" | "pro" | "enterprise" | nil,

    -- Endpoint patterns (Lua patterns)
    endpoints = { "pattern1", "pattern2", ... },

    -- Client identification strategy
    client_id_strategy = "api_key" | "ip" | "user_id" | "composite",

    -- Action when limit exceeded
    action = "reject" | "throttle" | "log_only",

    -- Metadata for tracking
    created_at = number,  -- unix timestamp
    updated_at = number,  -- unix timestamp
    version = number
}
```

**Example**:
```lua
local policy = {
    id = "free_tier_hourly",
    name = "Free Tier Hourly Limit",
    algorithm = "token_bucket",
    limit = 1000,
    period = 3600,
    burst = 50,
    tier = "free",
    endpoints = {"^/api/.*"},
    client_id_strategy = "api_key",
    action = "reject",
    created_at = 1698765600,
    updated_at = 1698765600,
    version = 1
}
```

### DM-02: Quota State

Quota state stored in Redis tracks current usage for each client.

**Token Bucket State**:
```lua
-- Redis key: "quota:token_bucket:{policy_id}:{client_id}"
-- Redis type: Hash
{
    tokens = number,          -- Current token count
    last_refill = number,     -- Last refill timestamp
    burst_tokens = number     -- Burst tokens available
}
```

**Sliding Window State**:
```lua
-- Redis key: "quota:sliding_window:{policy_id}:{client_id}"
-- Redis type: Sorted Set
-- Members: Request timestamps
-- Scores: Unix timestamp
-- TTL: Equal to policy period
```

**Fixed Window State**:
```lua
-- Redis key: "quota:fixed_window:{policy_id}:{client_id}:{window_start}"
-- Redis type: String (integer counter)
-- Value: Request count in current window
-- TTL: Equal to policy period
```

**Example Redis Operations**:
```lua
-- Token bucket: Get current state
local state = redis:hgetall("quota:token_bucket:free_tier_hourly:api_key_12345")

-- Sliding window: Add request timestamp
redis:zadd("quota:sliding_window:free_tier_hourly:api_key_12345",
           ngx.time(), ngx.time() .. ":" .. ngx.var.request_id)

-- Fixed window: Increment counter
redis:incr("quota:fixed_window:free_tier_hourly:api_key_12345:1698765600")
```

### DM-03: Rate Limit Result

Result object returned from rate limit check.

```lua
RateLimitResult = {
    -- Whether request is allowed
    allowed = boolean,

    -- Configured limit
    limit = number,

    -- Remaining quota in current period
    remaining = number,

    -- Unix timestamp when quota resets
    reset = number,

    -- Current algorithm in use
    algorithm = string,

    -- Policy that was applied
    policy_id = string,

    -- Reason for decision (for debugging)
    reason = string
}
```

**Example**:
```lua
{
    allowed = false,
    limit = 1000,
    remaining = 0,
    reset = 1698769200,
    algorithm = "token_bucket",
    policy_id = "free_tier_hourly",
    reason = "quota_exceeded"
}
```

## Algorithms

### Token Bucket Algorithm

The token bucket algorithm allows bursts while enforcing an average rate.

**Algorithm**:
```lua
function RateLimiter:_check_token_bucket(client_id, policy)
    local key = "quota:token_bucket:" .. policy.id .. ":" .. client_id
    local now = ngx.time()

    -- Get current state from Redis
    local state = redis:hgetall(key)

    local tokens = tonumber(state.tokens) or policy.limit
    local last_refill = tonumber(state.last_refill) or now
    local burst_tokens = tonumber(state.burst_tokens) or (policy.burst or 0)

    -- Calculate tokens to add based on elapsed time
    local elapsed = now - last_refill
    local refill_rate = policy.limit / policy.period
    local tokens_to_add = math.floor(elapsed * refill_rate)

    -- Refill tokens (capped at limit)
    tokens = math.min(tokens + tokens_to_add, policy.limit)

    -- Check if request can be served
    local allowed = false
    local remaining = tokens

    if tokens >= 1 then
        -- Use regular token
        tokens = tokens - 1
        allowed = true
        remaining = tokens
    elseif burst_tokens >= 1 then
        -- Use burst token
        burst_tokens = burst_tokens - 1
        allowed = true
        remaining = tokens + burst_tokens
    end

    -- Update state in Redis
    if allowed then
        redis:hmset(key,
            "tokens", tokens,
            "last_refill", now,
            "burst_tokens", burst_tokens
        )
        redis:expire(key, policy.period * 2)  -- TTL for cleanup
    end

    -- Calculate reset time
    local reset = now + math.ceil((1 - tokens) / refill_rate)

    return {
        allowed = allowed,
        limit = policy.limit,
        remaining = remaining,
        reset = reset,
        algorithm = "token_bucket",
        policy_id = policy.id
    }
end
```

**Complexity**: O(1)
**Redis Operations**: 1 HGETALL, 1 HMSET, 1 EXPIRE per request

### Sliding Window Algorithm

The sliding window algorithm provides accurate rate limiting without window boundary issues.

**Algorithm**:
```lua
function RateLimiter:_check_sliding_window(client_id, policy)
    local key = "quota:sliding_window:" .. policy.id .. ":" .. client_id
    local now = ngx.time()
    local window_start = now - policy.period

    -- Remove old requests outside the window
    redis:zremrangebyscore(key, 0, window_start)

    -- Count requests in current window
    local count = redis:zcard(key)

    local allowed = count < policy.limit
    local remaining = math.max(0, policy.limit - count)

    -- Add current request if allowed
    if allowed then
        local request_id = now .. ":" .. ngx.var.request_id
        redis:zadd(key, now, request_id)
        redis:expire(key, policy.period)
        remaining = remaining - 1
    end

    -- Calculate reset time (when oldest request exits window)
    local oldest = redis:zrange(key, 0, 0, "WITHSCORES")
    local reset = now + policy.period
    if #oldest > 0 then
        reset = tonumber(oldest[2]) + policy.period
    end

    return {
        allowed = allowed,
        limit = policy.limit,
        remaining = remaining,
        reset = reset,
        algorithm = "sliding_window",
        policy_id = policy.id
    }
end
```

**Complexity**: O(log N) where N is requests in window
**Redis Operations**: 1 ZREMRANGEBYSCORE, 1 ZCARD, 1 ZADD, 1 EXPIRE, 1 ZRANGE per request

**Trade-offs**:
- More accurate than fixed window
- Higher memory usage (stores all timestamps)
- Slightly higher latency (more Redis operations)

### Fixed Window Algorithm

The fixed window algorithm is the simplest but has boundary gaming issues.

**Algorithm**:
```lua
function RateLimiter:_check_fixed_window(client_id, policy)
    -- Calculate current window start
    local now = ngx.time()
    local window_start = math.floor(now / policy.period) * policy.period
    local key = "quota:fixed_window:" .. policy.id .. ":" ..
                client_id .. ":" .. window_start

    -- Get current count
    local count = tonumber(redis:get(key)) or 0

    local allowed = count < policy.limit
    local remaining = math.max(0, policy.limit - count - 1)

    -- Increment counter if allowed
    if allowed then
        redis:incr(key)
        redis:expire(key, policy.period)
    end

    -- Reset time is start of next window
    local reset = window_start + policy.period

    return {
        allowed = allowed,
        limit = policy.limit,
        remaining = remaining,
        reset = reset,
        algorithm = "fixed_window",
        policy_id = policy.id
    }
end
```

**Complexity**: O(1)
**Redis Operations**: 1 GET, 1 INCR, 1 EXPIRE per request

**Trade-offs**:
- Fastest performance
- Lowest memory usage
- Boundary gaming possible (2x limit if split across windows)

## Error Handling

### Redis Connection Failures

When Redis is unavailable, the middleware must fail gracefully according to configured `fail_mode`.

**Fail Open Mode** (default):
```lua
function RateLimiter:_handle_redis_error(err)
    ngx.log(ngx.ERR, "Redis error: ", err, " - failing open")

    -- Emit metric
    self.metrics:increment("rate_limit_redis_errors_total", {
        operation = "connection"
    })

    -- Allow request through
    return {
        allowed = true,
        limit = 0,
        remaining = 0,
        reset = ngx.time(),
        algorithm = "fallback",
        policy_id = "none",
        reason = "redis_unavailable_fail_open"
    }
end
```

**Fail Closed Mode**:
```lua
function RateLimiter:_handle_redis_error_closed(err)
    ngx.log(ngx.ERR, "Redis error: ", err, " - failing closed")

    -- Use local in-memory fallback with conservative limits
    local fallback_policy = {
        algorithm = "fixed_window",
        limit = 100,  -- Conservative limit
        period = 60   -- 1 minute window
    }

    return self:_check_local_fallback(ngx.var.remote_addr, fallback_policy)
end
```

### Invalid Policy Configuration

```lua
function RateLimiter:_validate_policy(policy)
    if not policy.algorithm then
        return false, "Missing required field: algorithm"
    end

    if not policy.limit or policy.limit <= 0 then
        return false, "Invalid limit: must be positive number"
    end

    if not policy.period or policy.period <= 0 then
        return false, "Invalid period: must be positive number"
    end

    local valid_algorithms = {
        token_bucket = true,
        sliding_window = true,
        fixed_window = true
    }

    if not valid_algorithms[policy.algorithm] then
        return false, "Invalid algorithm: " .. policy.algorithm
    end

    return true
end
```

### Request Timeout Handling

```lua
function RateLimiter:_check_with_timeout(client_id, policy, timeout_ms)
    -- Set Redis timeout
    redis:set_timeout(timeout_ms)

    local ok, result = pcall(function()
        return self:check_limit(client_id, policy)
    end)

    if not ok then
        ngx.log(ngx.WARN, "Rate limit check timed out: ", result)

        -- Return based on fail mode
        if self.config.fail_mode == "open" then
            return self:_handle_redis_error(result)
        else
            return self:_handle_redis_error_closed(result)
        end
    end

    return result
end
```

## Testing Strategy

### Unit Tests

Test individual algorithm implementations in isolation.

**Test Cases**:
1. **Token Bucket Tests**:
   - Initial request with full bucket
   - Request after partial refill
   - Burst capacity usage
   - Refill rate accuracy
   - Bucket overflow prevention

2. **Sliding Window Tests**:
   - Empty window
   - Window with old requests
   - Window at capacity
   - Request cleanup
   - Timestamp accuracy

3. **Fixed Window Tests**:
   - First request in window
   - Last request in window
   - Window transition
   - Counter accuracy

**Example Test**:
```lua
describe("Token Bucket Algorithm", function()
    it("should allow burst requests up to burst capacity", function()
        local limiter = RateLimiter:new(test_config)
        local policy = {
            algorithm = "token_bucket",
            limit = 100,
            period = 60,
            burst = 20
        }

        -- Make 25 rapid requests
        local allowed_count = 0
        for i = 1, 25 do
            local result = limiter:check_limit("test_client", policy)
            if result.allowed then
                allowed_count = allowed_count + 1
            end
        end

        -- Should allow first 20 (burst) + some from regular quota
        assert.is_true(allowed_count >= 20)
        assert.is_true(allowed_count <= 25)
    end)
end)
```

### Integration Tests

Test full request flow with real Redis instance.

**Test Scenarios**:
1. **Distributed Consistency**:
   - Multiple gateway instances
   - Concurrent requests from same client
   - Verify quota accurately tracked

2. **Policy Updates**:
   - Update policy mid-test
   - Verify new limits applied
   - Verify no request loss during update

3. **Failure Scenarios**:
   - Redis connection loss
   - Redis timeout
   - Invalid policy
   - Network partition

### Performance Tests

Benchmark latency and throughput under load.

**Metrics to Measure**:
- Requests per second (target: 100,000+)
- Latency percentiles (p50, p95, p99)
- Memory usage
- Redis connection pool saturation
- CPU utilization

**Load Test Setup**:
```bash
# Use wrk for load testing
wrk -t 12 -c 400 -d 30s \
    -H "X-API-Key: test_key_12345" \
    http://gateway:8080/api/test

# Expect:
# Requests/sec: 100,000+
# Latency p95: <10ms
# Latency p99: <20ms
```

## Performance Considerations

**Redis Connection Pooling**:
```lua
-- Reuse connections to minimize overhead
local redis = require "resty.redis"
local red = redis:new()

-- Set timeouts (connect, send, read)
red:set_timeouts(100, 1000, 1000)

-- Connect with connection pooling
local ok, err = red:connect(config.redis_host, config.redis_port)
if not ok then
    return nil, err
end

-- Return to pool instead of closing
local ok, err = red:set_keepalive(10000, 100)
```

**Lua Script Optimization**:
```lua
-- Use local variables to avoid table lookups
local ngx_time = ngx.time
local math_floor = math.floor
local math_min = math.min

-- Avoid string concatenation in hot path
local function build_key(policy_id, client_id)
    return table.concat({"quota", "token_bucket", policy_id, client_id}, ":")
end
```

**Redis Pipeline for Batch Operations**:
```lua
-- Instead of multiple roundtrips
redis:init_pipeline()
redis:hgetall(key)
redis:hmset(key, "tokens", tokens)
redis:expire(key, ttl)
local results, err = redis:commit_pipeline()
```

## Dependencies

**Required Libraries**:
- `lua-resty-redis`: Redis client for OpenResty
- `lua-cjson`: JSON encoding/decoding
- `lua-resty-lock`: Distributed locking (for policy updates)
- `lua-resty-http`: HTTP client (for policy fetching)

**External Services**:
- Redis 7.x cluster (with cluster mode enabled)
- Configuration API (for policy retrieval)
- Metrics endpoint (for Prometheus scraping)

**NGINX Modules**:
- `lua-nginx-module`: Lua support in NGINX
- `ngx_http_realip_module`: Real IP detection
- `ngx_http_auth_request_module`: Authentication integration
